<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Scribe App</title>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"
    ></script>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-gray-100 p-6" x-data="scribeApp()">
    <div class="max-w-4xl mx-auto bg-white p-8 rounded-lg shadow-lg">
      <h1 class="text-2xl font-bold mb-6">AI Scribe</h1>

      <!-- Authentication -->
      <div class="mb-4" x-show="!token">
        <label class="block mb-2 text-sm font-medium">Login</label>
        <input
          type="text"
          class="w-full p-2 border rounded"
          placeholder="Environment ID"
          x-model="envURL"
        />
        <input
          type="text"
          class="w-full p-2 border rounded mt-2"
          placeholder="Realm"
          x-model="realm"
        />
        <input
          type="text"
          class="w-full p-2 border rounded mt-2"
          placeholder="Username"
          x-model="username"
        />
        <input
          type="password"
          class="w-full p-2 border rounded mt-2"
          placeholder="Password"
          x-model="password"
        />
        <button
          class="bg-blue-500 text-white p-2 mt-4 rounded"
          @click="authenticate()"
        >
          Login
        </button>
      </div>

      <!-- Interaction Creation -->
      <div class="mb-4" x-show="token && !isRecording">
        <label class="block mt-4 mb-2 text-sm font-medium">Select Language</label>
        <select class="w-full p-2 border rounded" x-model="selectedLanguage">
          <option value="da">Danish</option>
          <option value="en">English</option>
        </select>

        <label class="block mt-4 mb-2 text-sm font-medium">Number of Streams</label>
        <input
          type="number"
          class="w-full p-2 border rounded"
          min="1"
          x-model.number="numberOfStreams"
        />

        <button
          class="bg-green-500 text-white p-2 mt-4 rounded"
          @click="startRecording()"
        >
          Start Dictation
        </button>
      </div>

      <!-- Recording Controls -->
      <div class="mb-4" x-show="isRecording">
        <div class="flex gap-1">
          <button
            class="bg-gray-500 text-white p-2 rounded"
            @click="pauseRecording()"
            x-show="!isPaused"
          >
            Pause
          </button>
          <button
            class="bg-green-500 text-white p-2 rounded"
            @click="resumeRecording()"
            x-show="isPaused"
          >
            Resume
          </button>
          <button
            class="bg-red-500 text-white p-2 rounded"
            @click="stopRecording()"
          >
            Stop
          </button>
        </div>
      </div>

      <!-- Transcriptions Log -->
      <div class="grid grid-cols-1 gap-4" x-show="isRecording">
        <div class="mb-4">
          <h2 class="text-xl font-bold">Transcriptions</h2>
          <template x-for="(streamTranscriptions, index) in transcriptions" :key="index">
            <div>
                <h3 class="text-lg font-semibold" x-text="'Stream ' + (index + 1)"></h3>
                <ul class="list-disc ml-6">
                <template x-for="transcription in streamTranscriptions" :key="transcription.id">
                  <li x-text="transcription.text"></li>
                </template>
              </ul>
            </div>
          </template>
        </div>
      </div>
    </div>

    <script>
      function scribeApp() {
        return {
          envURL: localStorage.getItem("envURL") || "beta-eu",
          realm: localStorage.getItem("realm") || "copiloteu",
          username: localStorage.getItem("username") || "",
          password: localStorage.getItem("password") || "",
          token: "",
          selectedLanguage: "da",
          numberOfStreams: 1,
          transcriptions: [],
          streams: [],
          isRecording: false,
          isPaused: false,

          authenticate() {
            const url = `https://keycloak.${this.envURL}.corti.app/realms/${this.realm}/protocol/openid-connect/token`;
            fetch(`http://localhost:8080/${url}`, {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
              },
              body: new URLSearchParams({
                username: this.username,
                password: this.password,
                grant_type: "password",
                client_id: "copilot-frontend",
                scope: "openid",
              }),
            })
              .then((response) => response.json())
              .then((data) => {
                this.token = data.access_token;
                localStorage.setItem("envURL", this.envURL);
                localStorage.getItem("realm", this.realm);
                localStorage.setItem("username", this.username);
                localStorage.setItem("password", this.password);
              })
              .catch((error) => console.error("Error:", error));
          },

          startRecording() {
    this.isRecording = true;
    this.isPaused = false;
    this.transcriptions = Array.from({ length: this.numberOfStreams }, () => []);
    
    // Initialize allStreamData object on start
    window.allStreamData = {
        envURL: this.envURL,
        start_time: new Date().toISOString(),
        number_of_streams: this.numberOfStreams,
        selectedLanguage: this.selectedLanguage,
        streams: []
    };

    navigator.mediaDevices
        .getUserMedia({ audio: true })
        .then((stream) => {
            for (let i = 0; i < this.numberOfStreams; i++) {
                const ws = new WebSocket(
                    `wss://api.${this.envURL}.corti.app/audio-bridge/v1/transcribe?token=Bearer%20${this.token}`
                );

                ws.onopen = () => {
                    const streamObject = {
                        index: i,
                        start_time: new Date().toISOString(),
                        events: []
                    };
                    // Push each new stream into the streams array in allStreamData
                    window.allStreamData.streams.push(streamObject);

                    ws.send(
                        JSON.stringify({
                            event: "START",
                            metadata: {
                                language: this.selectedLanguage,
                                previewResults: false,
                            },
                        })
                    );
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    const currentTime = new Date();
                    const stream = window.allStreamData.streams[i];

                    // Calculate time since start of stream
                    const timeSinceStart = (currentTime - new Date(stream.start_time)) / 1000;

                    // Push the event data into the events array of the relevant stream
                    stream.events.push({
                        time: currentTime.toISOString(),
                        time_since_start: parseFloat(timeSinceStart.toFixed(3)),
                        data
                    });

                    if (data.type === "dictation" && data.data.final) {
                        const record = {
                            id: Math.random().toString(36).substr(2, 9),
                            text: data.data.text,
                        };
                        this.transcriptions[i].push(record);
                    }
                };

                ws.onerror = (error) => console.error(`WebSocket error for stream ${i + 1}:`, error);

                const recorder = new MediaRecorder(stream);
                recorder.start(250);
                recorder.addEventListener("dataavailable", (event) => {
                    if (event.data.size > 0 && ws.readyState === 1 && !this.isPaused) {
                        ws.send(event.data);
                    }
                });

                this.streams.push({ websocket: ws, recorder });
            }
        });
},

          pauseRecording() {
            this.isPaused = true;
          },

          resumeRecording() {
            this.isPaused = false;
          },

          stopRecording() {
            this.isRecording = false;
            this.isPaused = false;
            this.streams.forEach(({ websocket, recorder }, index) => {
              if (websocket.readyState === 1) {
                websocket.send(JSON.stringify({ event: "STOP" }));
              }
              recorder.stop();
              websocket.close();
            });
            this.streams = [];
          },

          init() {
            if (this.username && this.password) {
              this.authenticate();
            }
          },
        };
      }
    </script>
  </body>
</html>
